"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FHIRDefinitions = void 0;
const lodash_1 = require("lodash");
const fhir_package_loader_1 = require("fhir-package-loader");
const utils_1 = require("../utils");
const impliedExtensions_1 = require("./impliedExtensions");
const fhirtypes_1 = require("../fhirtypes");
const common_1 = require("../fhirtypes/common");
class FHIRDefinitions extends fhir_package_loader_1.FHIRDefinitions {
    constructor(isSupplementalFHIRDefinitions = false) {
        super();
        this.isSupplementalFHIRDefinitions = isSupplementalFHIRDefinitions;
        this.predefinedResources = new Map();
        this.supplementalFHIRDefinitions = new Map();
        // FHIR R4 does not have a StructureDefinition that defines "Base" but FHIR R5 does.
        // We have defined a "placeholder" StructureDefinition for "Base" for R4.
        // Inject the R4 "Base" placeholder StructureDefinition
        this.add(fhirtypes_1.STRUCTURE_DEFINITION_R4_BASE);
    }
    // This getter is only used in tests to verify what supplemental packages are loaded
    get supplementalFHIRPackages() {
        return (0, lodash_1.flatten)(Array.from(this.supplementalFHIRDefinitions.keys()));
    }
    allPredefinedResources() {
        return Array.from(this.predefinedResources.values()).map(v => (0, lodash_1.cloneDeep)(v));
    }
    add(definition) {
        // For supplemental FHIR versions, we only care about resources and types,
        // but for normal packages, we care about everything.
        if (this.isSupplementalFHIRDefinitions) {
            if (definition.resourceType === 'StructureDefinition' &&
                (definition.kind === 'primitive-type' ||
                    definition.kind === 'complex-type' ||
                    definition.kind === 'datatype' ||
                    (definition.kind === 'resource' && definition.derivation !== 'constraint'))) {
                super.add(definition);
            }
        }
        else {
            super.add(definition);
        }
    }
    addPredefinedResource(file, definition) {
        this.predefinedResources.set(file, definition);
    }
    getPredefinedResource(file) {
        return this.predefinedResources.get(file);
    }
    resetPredefinedResources() {
        this.predefinedResources = new Map();
    }
    addSupplementalFHIRDefinitions(fhirPackage, definitions) {
        this.supplementalFHIRDefinitions.set(fhirPackage, definitions);
    }
    getSupplementalFHIRDefinitions(fhirPackage) {
        return this.supplementalFHIRDefinitions.get(fhirPackage);
    }
    fishForPredefinedResource(item, ...types) {
        const resource = this.fishForFHIR(item, ...types);
        if (resource &&
            this.allPredefinedResources().find(predefResource => predefResource.id === resource.id &&
                predefResource.resourceType === resource.resourceType &&
                predefResource.url === resource.url)) {
            return resource;
        }
    }
    fishForPredefinedResourceMetadata(item, ...types) {
        const resource = this.fishForPredefinedResource(item, ...types);
        if (resource) {
            return {
                id: resource.id,
                name: resource.name,
                sdType: resource.type,
                url: resource.url,
                parent: resource.baseDefinition,
                abstract: resource.abstract,
                version: resource.version,
                resourceType: resource.resourceType
            };
        }
    }
    fishForFHIR(item, ...types) {
        const def = super.fishForFHIR(item, ...types);
        if (def) {
            return def;
        }
        // If it's an "implied extension", try to materialize it. See:http://hl7.org/fhir/versions.html#extensions
        if (impliedExtensions_1.IMPLIED_EXTENSION_REGEX.test(item) && types.some(t => t === utils_1.Type.Extension)) {
            return (0, impliedExtensions_1.materializeImpliedExtension)(item, this);
        }
    }
    fishForMetadata(item, ...types) {
        var _a, _b;
        const result = this.fishForFHIR(item, ...types);
        if (result) {
            let canBeTarget;
            if (result.resourceType === 'StructureDefinition' && result.kind === 'logical') {
                canBeTarget =
                    (_b = (_a = result.extension) === null || _a === void 0 ? void 0 : _a.some((ext) => {
                        return (((ext === null || ext === void 0 ? void 0 : ext.url) === common_1.TYPE_CHARACTERISTICS_EXTENSION && (ext === null || ext === void 0 ? void 0 : ext.valueCode) === 'can-be-target') ||
                            ((ext === null || ext === void 0 ? void 0 : ext.url) === common_1.LOGICAL_TARGET_EXTENSION && (ext === null || ext === void 0 ? void 0 : ext.valueBoolean) === true));
                    })) !== null && _b !== void 0 ? _b : false;
            }
            return {
                id: result.id,
                name: result.name,
                sdType: result.type,
                url: result.url,
                parent: result.baseDefinition,
                abstract: result.abstract,
                version: result.version,
                resourceType: result.resourceType,
                canBeTarget
            };
        }
    }
}
exports.FHIRDefinitions = FHIRDefinitions;
//# sourceMappingURL=FHIRDefinitions.js.map